DataBase

在mysql中做统计的时候，count（*）会扫描所有的行数，不管行的值是否为空，count（'column name'）会过滤掉值为空的行，count（1）的意思就是扫描主键所对应的列，效率会比count（*）高
ifnull(code_mode,'unknown')的意思就是如果code_mode的值为NULL，那么对其赋值为unknown
substring(str, begin, end),表示从开始到结束的位置截取字符串字段，字段的位置从1开始算
case value
when xxx value1
when xxx value2
end
表示先取value的值，然后进行条件判断，然后根据判断赋予新的值
MYSQL语句之间，各个语句之间一般是不要加，号的，只有在同一个语句内的几个变量之间才需要加，号

修改mysql里面表的结构，使用alter tablename命令，例如修改表里面一列的类型定义
alter tablename modify 列名 varchar(255);   将会把该列的类型定义为255长度字符串
SQL查询中，添加distinct统计中去除重复数据（count（distinct xxx））

左链接会显示左表的所有数据，然后会根据链接中的条件显示右表中符合条件的数据（一般会设置两边的ID匹配，简单来说join就是在一张表上面格外再显示一些字段），如果右表里面会多个数据匹配的话，会重复显示左表的数据（比如一个表存基本信息，另外一个表存一些属性信息），这种情况，一般使用GROUPCONTACT函数，此函数可以将零散的属性信息合并到一起，相同ID仅显示一行数据，合并后的数据会使用；进行分隔

在mysql语句中，<>符号为不等于的意思，同时将变量与Null进行比较的时候，需要使用 is Null或者is not Null，不能使用 = Null的表达式
mysql中， case 
	      when  people.sex='male' then 'boy'
	      when  people.sex='female' then 'girl'
	      else 'ladyboy'
         end
要判断的值可以放在when里面，也可以直接放在case当中，就和switch case的用法一样了

创建index时需要为索引名称以及索引对应的column名称，然后会选择索引的类型
主要有三种索引类型：
（1）normal：
（2）full-text：用于文本的索引（列类型要是char、text、varchar），可以避免文本搜索使用like效率低下的问题，full-text一般使用的场景是长文本当中搜索一些词语，mysql在创建索引的时候会对文本进行自然语言处理，同时需要注意的是full-text索引无法为单列数据创建，需要针对多列数据联合创建full-text索引，由此可见，创建full-text索引的开销还是很大的
（3）unique： 如果可以保证索引列的值唯一就可以创建为此类型（一般为id类）
然后需要选择索引方法，在mysql中主要有两种
（1）b-tree，  也就是使用b-tree来储存、查找索引，同时这种类型的b-tree会在叶子节点一并存储索引所对应的行的其它列的信息
（2）hash，也就是通过hash-map来储存一行或者多行对应的hash值，查找的时候直接查找hash-map得到结果，所以有map所对应的各种特点，无法范围搜索（hash map一对一），查找的结果无序（hash map本身就是无序的）
使用了索引之后，你会发现删除的时候效率会比较低，这是因为每次删除数据会重新生成索引树（删除叶子节点，插入父节点等操作），所以使用索引的时候最好针对频繁查找但是偶尔进行修改、删除的数据
对于使用了索引又需要进行删除的数据，有一种解决办法就是进行假删除，只是让原本的数据检索不到，但是数据在数据库当中依然真实存在、亦或是可以只删除数据而不删除索引的数据

MYSQL里面一直复杂的操作，例如多表的删除、修改操作，最好使用事务来完成，事务可以在执行的时候避免这一组语句之间的冲突，而且在保证这些语句均执行成功后才提交保存改动，失败的时候会执行回退；
一般也可以创建函数或者存储过程（Procedure）来执行事务，其实相当于一个小脚本，把一堆SQL语句包裹起来，注意的是里面的每句均需要加上分号，同时需要定义好输入的参数，函数还需要定义好输出参数的类型、长度；（ALTER语句仅仅只能修改函数和过程的参数信息，无法修改body，所以需要先删除，再重新添加）
同时在写存储过程的时候可以在语句当中定义临时变量，使用select * INTO  xxx的形式进行赋值

MYSQL在使用DELETE语句做多表关联删除的时候有BUG，在使用subquery的时候是无法使用到索引的（看stackoverflow上面的老哥说的是因为subquery创建的是一张虚拟的表单，所以无法关联到索引，但是我索引关联的不是subquery出来的临时表单啊），总之类似这种形式的语句是无法使用索引的：
DELETE FROM t_aw_baw  WHERE tag_id IN (SELECT tag.uuid FROM t_aw_tag AS tag LEFT JOIN t_aw_info AS aw ON tag.aw_id = aw.uuid WHERE aw_id = _aw_id);
将其修改为：
DELETE t_aw_caw from t_aw_caw INNER JOIN (SELECT tag.uuid FROM t_aw_tag AS tag LEFT JOIN t_aw_info AS aw ON tag.aw_id = aw.uuid WHERE tag.aw_id=_aw_id) AS aw_tag ON (t_aw_caw.tag_id=aw_tag.uuid);
去掉了IN，先提取出子查询中的tag_id记录，然后再使用INNER JOIN将符合条件的caw表中内容列出，然后再将其删除；

在mysql当中，使用索引虽然可以大大提高查询的速度，但是由于索引是格外增加存储空间，所以对于列表更新（insert，update，delete）这些写操作的效率是降低的，因为写的时候要额外操作存储空间作为索引的使用，所以对于频繁要进行写操作的表单建立索引一定要慎重；


在存储过程当中，根据某一些条件进行操作的时候，可以设置一个局部变量var，利用SELECT xxx INTO var 的形式，首先为var赋值，然后再根据var的值来进行操作；

在迁移数据库的时候，需要一并将mysql的配置文件拷贝过去（mysql当中会有很多关于模式、视图的设置）


3.InnoDB的隔离等级以及ACID：
ACID即标准的事务系统的重要特性，分别为：
原子性：一个事务当中的操作要么全部都执行成功，不存在一部分语句成功，一部分语句失败的情况，这里我的理解就是如果有语句执行不成功，则整个事务进行回滚，回复到事务开始之前的状态
一致性：一个事务的执行保证整个事务由一个一致性的状态转移到另一个一致性的状态，这里我的理解就是只有提交之后才会生效
持久性：数据库引擎保证了事务对数据库数据做的改变是能够写入数据库的（实际上对数据的改变不是立即执行，而是交给后台的worker去执行）
隔离性：一个事务操作的动作不会影响其他的事务执行，这里就涉及到InnoDB的隔离级别了，实际是并不能做到事务之间完全的隔离
四种隔离性（第二次敲这个内容了，上一次完全copy别人的语句，这一次自己写吧）：
1. uncommitted read： 未提交读取，很好理解，就是一个事务能够读取到另外一个事务还没有提交但是已经做出的修改；试想一下，如果事务A修改了一行数据，这个时候事务B正好读取到了这行数据，但是最终事务A执行了回滚，那么事务B实际上读取到了错误的数据，这个就叫做"脏读"
2. committed read: 提交读取，就是只能读取到事务已经提交之后的数据，比如事务A对一行做修改，这个时候由于事务A还没有提交，事务B读取到这一行的数据是修改前的数据，直到事务A提交之后，事务B才会读取到这一行的新值；但是又引入了一个问题，就是多次读取到的数据是不一致的，比如事务B里面有多个语句都对同一行进行操作，可能会造成事务逻辑的混乱，这个叫做不可重复读
3. repeatable read（InnoDB的默认隔离级别）：可重复读，这个隔离等级满足了一个事务当中对一行数据的多次读取都是一致的，具体原理是通过MVCC来实现的，简单理解就是每一次事务执行都对一行添加一个版本号（版本号根据时间的先后进行累加），一个事务只会读取版本号早于自己的行数据（被操作的行数据都会添加多版本的数据），这样就保证了多次读取的结果都是一致的
4. Serializable： 串行化，这个隔离等级保证了事务与事务之间是串行化的执行方式，一个事务执行完毕之后才能执行下一个事务（需要通过大量的锁操作来实现），只有在需要非常严格的数据一致性以及不需要并发的情况才考虑
4.Mysql的索引数据结构（又找了一篇教程来研习，这次好像可以轻松看懂了。。）：
主要讨论MyISAM和InnoDB的索引数据结构，两种引擎的索引都是基于B+树的，B+树是B-树的变种，B-树是一种非二叉树的树形数据结构，分层排列（每一层都多个节点，每个节点存储多个key以及多个指针，指针指向节点的子节点），其实简单来说就是从根节点到叶子节点的范围逐渐变细，可以完美适配索引通过分层遍历快速定位到数据地址，同时我们知道索引一般数据量会比较大而不能直接放到内存当中去，所以一般都需要从磁盘当中读取索引，而数据库的设计者将B-树当中的一个Node设计为一个page的大小，而磁盘每次会从磁盘当中预读N个page的数据，这样就适配了磁盘的读取规则，减少了磁盘读取的次数
而B+树在B-树基础之上做了一些改变，B-树会在每个节点处都覆盖数据，而B+树只在叶子节点附带数据（变向增加了每一层的出度）
对于MyISAM主索引表来说，在叶子节点会除了存储主键之外，还会存储对应数据行的地址，通过地址再去获取行数据
对于InnoDB来说，在叶子节点会附带完整的行数据，InnoDB在创建表的时候就会一并将表数据存储为B+树的数据结构，这个是主键的索引结构，如果创建辅助索引的话，辅助索引的叶子节点会附带主键的值







